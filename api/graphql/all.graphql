scalar ID
scalar Cursor
scalar UriString
scalar Moment

interface Node {

    id: ID!
}

interface Edge {

    cursor: Cursor!
    node: Node!
}

type PageInfo {

    startCursor: Cursor
    endCursor: Cursor
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}

interface TimeDetail {

    created: Moment!
    lastUpdated: Moment!
}

interface Connection {

    totalCount: Int!
    pageInfo: PageInfo!
    edges: [Edge!]!
    nodes: [Node!]!
}

#
# A GraphQL directive type that is used to highlight different parts of the API to note the API's
# availability. The `type` field is an `AccessType` enum value indicating the availability of the
# API.
#
# **Note** that if this directive is applied to a type, then all it's subfields are considered as
# having the same directive applied to them, unless explicitly defined otherwise.
#
# **Note** that if a server implementation of this API does not conform to the specified `@access`
# directive, then they could either possibly expose a security risk or break a client's ability to
# work with the server. For instance, if an expected `OPEN` part of the API is restricted, such as,
# with the `LoginInfo`, then a client might consider that the server doesn't implement the API at
# all.
#
directive @access(
    type: AccessType!
) on OBJECT | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | ENUM

#
# A GraphQL enum type that defines the different access strategies for the API. This enum type is
# used within the `@access` directive to highlight different parts of the API to note the API's
# availability.
#
# Available values are:
# * OPEN
# * LOGIN_STRATEGY
#
# The `OPEN` value indicates that part of the API should be available to anyone querying the API.
# Whereas, the `LOGIN_STRATEGY` value  indicates that part of the API's access is dependent on the
# `LoginType`. For instance, if the `LoginType` is `NONE`, then that part of the API should be
# available to anyone querying the API, similar to the `OPEN` `AccessType`.
#
# * `AccessType.OPEN` -> Open API section
# * `AccessType.LOGIN_STRATEGY` with `LoginType.NONE` -> Open API section
# * `AccessType.LOGIN_STRATEGY` with `LoginType.OPTIONAL` -> Open API section with limited results
# * `AccessType.LOGIN_STRATEGY` with `LoginType.REQUIRED` -> Secured API section requires auth
#
enum AccessType {
    OPEN
    LOGIN_STRATEGY
}

type VideoEdge implements Edge @access(type: LOGIN_STRATEGY) {
    cursor: Cursor!
    node: Video!
}


enum VideoStreamType @access(type: LOGIN_STRATEGY) {
    PROGRESSIVE
    DASH
    SMOOTH_STREAMING
    HLS
}

interface VideoAction {
    type: String!
}

interface SelectableAction {
    isSelected: Boolean!
}

type DownloadAction implements VideoAction @access(type: LOGIN_STRATEGY) {
    type: String!
    downloadUri: UriString!
}

type RatingUpAction implements VideoAction & SelectableAction @access(type: LOGIN_STRATEGY) {
    type: String!
    isSelected: Boolean!
}

type RatingDownAction implements VideoAction & SelectableAction @access(type: LOGIN_STRATEGY) {
    type: String!
    isSelected: Boolean!
}

type FlagAction implements VideoAction & SelectableAction @access(type: LOGIN_STRATEGY) {
    type: String!
    isSelected: Boolean!
}

enum SelectableVideoActionType @access(type: LOGIN_STRATEGY) {
    RATING_UP
    RATING_DOWN
    FLAG
}

type Subtitle @access(type: LOGIN_STRATEGY) {
    locale: String!
    uri: UriString!
    format: SubtitleFormat!
}

enum SubtitleFormat @access(type: LOGIN_STRATEGY) {
    WEB_VTT
    TTML
    SUB_RIP
    SUB_STATION_ALPHA
}

enum DrmScheme @access(type: LOGIN_STRATEGY) {
    CENC
    CBCS
    CBC1
    CENS
    CLEAR_KEY
    PLAYREADY_SL2000
}

type DrmInfo @access(type: LOGIN_STRATEGY) {
    licenseServerUrl: UriString!
    scheme: DrmScheme!
    multiSession: Boolean!
    offlineLicenseKeySetId: String
}

type Video implements Node & TimeDetail @access(type: LOGIN_STRATEGY) {
    id: ID!
    created: Moment!
    lastUpdated: Moment!
    published: Moment!
    uri: UriString!
    name: String!
    description: String
    about: String
    previewImage: UriString
    category: String
    tags: [String!]!
    viewCount: Int
    isLive: Boolean!
    lengthInMilliseconds: Int!
    streamType: VideoStreamType!
    standaloneSubtitles: [Subtitle!]!
    drmInfo: DrmInfo
    locale: String
    actions: [VideoAction!]!
    related(take: Int!, after: Cursor): VideoConnection!
}

type VideoConnection implements Connection @access(type: LOGIN_STRATEGY) {
    pageInfo: PageInfo!
    totalCount: Int!
    edges: [VideoEdge!]!
    nodes: [Video!]!
}

type ChannelImageInfo @access(type: LOGIN_STRATEGY) {
    thumbnail: UriString
    banner: UriString
}

type ChannelCountInfo @access(type: LOGIN_STRATEGY) {
    totalSubscribers: Int!
    totalVideoViews: Int!
}

type ChannelVideoListConnection implements Connection @access(type: LOGIN_STRATEGY) {
    id: ID!
    name: String!
    totalCount: Int!
    pageInfo: PageInfo!
    edges: [VideoEdge!]!
    nodes: [Video!]!
}

type ChannelEdge implements Edge @access(type: LOGIN_STRATEGY) {
    cursor: Cursor!
    node: Channel!
}

type Channel implements Node & TimeDetail @access(type: LOGIN_STRATEGY) {
    id: ID!
    created: Moment!
    lastUpdated: Moment!
    published: String!
    name: String!
    description: String
    about: String
    website: UriString
    images: ChannelImageInfo!
    count: ChannelCountInfo!
    isSubscribed: Boolean!
    lists: [ChannelVideoListConnection!]!
    list(id: ID!, take: Int!, after: Cursor): ChannelVideoListConnection!
    videos(take: Int!, after: Cursor): VideoConnection!
    video(id: ID!): Video
}

type ChannelConnection implements Connection @access(type: LOGIN_STRATEGY) {
    pageInfo: PageInfo!
    totalCount: Int!
    edges: [ChannelEdge!]!
    nodes: [Channel!]!
}

union FeedItem = VideoFeedItem

type VideoFeedItem @access(type: LOGIN_STRATEGY) {
    channel: Channel!
    video: Video!
}

type FeedEdge @access(type: LOGIN_STRATEGY) {
    cursor: Cursor!
    node: FeedItem!
}

type FeedConnection @access(type: LOGIN_STRATEGY) {
    pageInfo: PageInfo!
    totalCount: Int!
    edges: [FeedEdge!]!
    nodes: [FeedItem!]!
}

#
# A GraphQL type that represents login information for a User to access data from the API.
#
# The `type` field indicates whether a User is required to login to access data or not. This is a
# required field.
#
# The `loginUri` field is the URI to redirect to so that the User can login. This is an optional
# field, however, if the `LoginType` is `REQUIRED` or `OPTIONAL` this value must be available. If
# the `LoginType` is `NONE`, then this value should be null.
#
# The `requestId` is a server provided unique identifier used in the login process. This is an
# optional property. If it is available and the `LoginType` is `REQUIRED` or `OPTIONAL` then it
# will be added as a query parameter (ex: `?requestId=12345`) of the `loginUri` when redirecting to
# login. **Note** that this alone is not a security indicator and is simply used to allow the
# server to identify the login request.
#
# **Note** that this type has an `AccessType` of `OPEN`. If this isn't available for any client
# querying the API, then there will be no way for the User to login from the client.
#
type LoginInfo @access(type: OPEN) {
    type: LoginType!
    loginUri: UriString
    requestId: ID
}

#
# A GraphQL enum type that defines the different login approaches. This enum type is used within
# the `LoginInfo` type to indicate whether a User must login before accessing data from this API.
#
# Available values are:
# * REQUIRED
# * OPTIONAL
# * NONE
#
# The `NONE` value indicates that the User can access data from this API, such as `Videos`, without
# having to login. The `OPTIONAL` value indicates that User can choose to login but it is not
# required. Some additional data may be available to a logged-in User that might not be available
# to a User that is not logged-in. The `REQUIRED` value indicates that the User must login before
# accesssing data from this API.
#
# `LoginType.REQUIRED` -> User must login to access data from the API
# `LoginType.OPTIONAL` -> User may login to possibly have more data from the API available
# `LoginType.NONE` -> User does not have to login to access data from the API
#
enum LoginType @access(type: OPEN) {
    REQUIRED
    OPTIONAL
    NONE
}

type Mutation @access(type: LOGIN_STRATEGY) {
    toggleVideoAction(videoId: ID!, type: SelectableVideoActionType!): VideoAction!
    toggleSubscription(channelId: ID!): Channel!
}

type Provider implements TimeDetail @access(type: OPEN) {
    created: Moment!
    lastUpdated: Moment!
    uri: UriString!
    name: String!
    description: String
    about: String
    website: String
    contactEmail: String
    images: ProviderImageInfo!
    channels(take: Int!, after: Cursor): ChannelConnection! @access(type: LOGIN_STRATEGY)
    channel(id: ID!): Channel @access(type: LOGIN_STRATEGY)
}

type ProviderImageInfo @access(type: OPEN) {
    thumbnail: UriString
    banner: UriString
}

union SearchResultItem = VideoSearchResultItem | ChannelSearchResultItem

type VideoSearchResultItem {
    video: Video!
    channel: Channel!
}

type ChannelSearchResultItem {
    channel: Channel!
}

type SearchResultEdge @access(type: LOGIN_STRATEGY) {
    cursor: Cursor!
    node: SearchResultItem!
}

type SearchResultConnection @access(type: LOGIN_STRATEGY) {
    pageInfo: PageInfo!
    totalCount: Int!
    edges: [SearchResultEdge!]!
    nodes: [SearchResultItem!]!
}

#
# A GraphQL type representing the Viewer or User of the Client who is accessing the APIs. All of
# the APIs should be scoped with respect to the `Viewer`. For example, the `feed` field on the
# `Query` object should return items relevant to this `Viewer`.
#
# `name` - The name to use for this `Viewer`. This value is up to the server implementation and can
# be anything that will be visible to the `Viewer`. For example, this could be the full name, first
# name, username, email, or any other User defined value. Howerver, it is recommended not to expose
# secure information, such as, an email.
#
# `isAuthenticated` - Indicates whether this `Viewer` is authenticated (logged-in) or not.
#
# `subscribedChannels` - A `ChannelConnection` linking to the `Channels` that this User has
# subscribed to.
#
type Viewer implements Node & TimeDetail @access(type: LOGIN_STRATEGY) {
    id: ID!
    created: Moment!
    lastUpdated: Moment!
    name: String!
    isAuthenticated: Boolean!
    subscribedChannels(take: Int!, after: Cursor = null): ChannelConnection!
}


type Query @access(type: OPEN) {
    apiVersion: String! @access(type: OPEN)
    login: LoginInfo! @access(type: OPEN)
    provider: Provider! @access(type: OPEN)
    viewer: Viewer! @access(type: LOGIN_STRATEGY)
    search(query: String!, take: Int!, after: Cursor = null): SearchResultConnection! @access(type: LOGIN_STRATEGY)
    feed(take: Int!, after: Cursor = null): FeedConnection! @access(type: LOGIN_STRATEGY)
}

schema {
    query: Query
    mutation: Mutation
}